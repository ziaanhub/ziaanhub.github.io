<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ZiaanHub — Neraka Minecraft Pixel 3D</title>

  <!-- React (untuk UI wrapper; kita akan render scene ke canvas) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <!-- OrbitControls (dev camera control) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/examples/js/controls/OrbitControls.js"></script>

  <!-- GSAP for animation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.1/gsap.min.js"></script>

  <!-- Simplex Noise for lava shader-like movement (tiny lib) -->
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/esm/simplex-noise.min.js"></script>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>

  <style>
    :root{
      --bg:#0a0403; --text:#ffe8e8; --accent:#ff3b3b;
    }
    html,body { height:100%; margin:0; background:linear-gradient(180deg,#050101 0%, #120202 70%); color:var(--text); font-family:Inter, system-ui, sans-serif; -webkit-font-smoothing:antialiased;}
    #root { height:100vh; width:100vw; display:flex; align-items:center; justify-content:center; }
    .app {
      width:100%;
      height:100%;
      position:relative;
      overflow:hidden;
    }

    /* Top HUD */
    .hud {
      position:absolute;
      top:18px;
      left:18px;
      z-index:20;
      display:flex;
      gap:10px;
      align-items:center;
      backdrop-filter: blur(6px);
      background: rgba(30,8,8,0.35);
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255, 60, 60, 0.06);
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    }
    .hud .title { font-weight:700; letter-spacing:1px; color:var(--accent); }
    .hud button { background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:8px; cursor:pointer; }
    .hud small { color:#ffbcbc; opacity:0.9; margin-left:8px; font-size:12px; }

    /* Bottom info (we'll hide tiny footer as user requested) */
    .controls {
      position:absolute;
      right:18px;
      bottom:18px;
      z-index:20;
      display:flex;
      gap:8px;
      align-items:center;
      background: rgba(20,6,6,0.35);
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255, 60, 60, 0.06);
    }
    .controls .ghost { color:#ffb2b2; font-size:13px; }

    /* Canvas occupies full */
    canvas { display:block; width:100%; height:100%; outline:none; }

    /* mobile hint */
    .mobile-hint {
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top:18px;
      z-index:21;
      padding:6px 8px;
      background:rgba(0,0,0,0.35);
      border-radius:8px;
      font-size:13px;
      color:#ffdddd;
      display:none;
    }
    @media (max-width:820px){
      .mobile-hint { display:block; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/javascript">
  // ---------- React wrapper ----------
  const e = React.createElement;

  function App(){
    return e('div', {className:'app'},
      e('div',{className:'hud'},
        e('div',{className:'title'}, 'ZiaanHub — Nether Pixel 3D'),
        e('button',{id:'btn-pause'}, 'Pause'),
        e('small', null, 'Klik/Drag pada logo untuk efek pixel')
      ),
      e('div',{className:'mobile-hint'}, 'Ketuk & seret untuk interaksi'),
      e('div',{id:'three-container', style:{width:'100%', height:'100%'}})
    );
  }

  ReactDOM.createRoot(document.getElementById('root')).render(e(App));

  // ---------- Three.js Scene ----------
  (function(){
    // Globals
    const container = document.getElementById('three-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0302, 0.015);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, preserveDrawingBuffer:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Camera
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 2000);
    camera.position.set(0, 30, 120);

    // Controls (for desktop dev; hidden on mobile gestures still work)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.enabled = false; // disabled by default; toggle with "P" or button

    // Lighting (hellish red)
    const hemi = new THREE.HemisphereLight(0xffd1b8, 0x200000, 0.4);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xff6b4d, 1.4);
    dir.position.set(50,80,50);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048,2048);
    dir.shadow.camera.near=1; dir.shadow.camera.far=300;
    scene.add(dir);

    // Ambient red tint
    const ambient = new THREE.AmbientLight(0x220000, 0.6);
    scene.add(ambient);

    // Ground lava plane
    const lavaGeo = new THREE.PlaneGeometry(600, 600, 120, 120);
    const lavaMat = new THREE.MeshStandardMaterial({
      emissive: 0xff3a00,
      emissiveIntensity: 1.2,
      metalness: 0.1,
      roughness: 0.85,
      transparent: true,
      opacity: 0.95,
    });
    const lava = new THREE.Mesh(lavaGeo, lavaMat);
    lava.rotation.x = -Math.PI/2;
    lava.position.y = -30;
    lava.receiveShadow = true;
    scene.add(lava);

    // Simple noise for lava animation
    const simplex = new SimplexNoise();

    // Particle (embers) system
    const emberCount = 260;
    const emberGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(emberCount*3);
    const sizes = new Float32Array(emberCount);
    for(let i=0;i<emberCount;i++){
      positions[i*3+0] = (Math.random()-0.5)*300;
      positions[i*3+1] = Math.random()*40 - 10;
      positions[i*3+2] = (Math.random()-0.5)*300;
      sizes[i] = Math.random()*2.5 + 0.6;
    }
    emberGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    emberGeo.setAttribute('size', new THREE.BufferAttribute(sizes,1));
    const emberMat = new THREE.PointsMaterial({
      size: 6,
      sizeAttenuation: true,
      color: 0xff6f3e,
      transparent:true,
      opacity:0.9,
      depthWrite:false,
      blending:THREE.AdditiveBlending
    });
    const embers = new THREE.Points(emberGeo, emberMat);
    scene.add(embers);

    // Create pixel text using a canvas to sample text pixels
    const text = "ZiaanHub";
    const pixelSize = 2.6; // cube size
    const scale = 2.6; // scaling factor for spacing
    const gap = 0.6; // small gap between cubes

    // create a temporary canvas to rasterize text
    const textCanvas = document.createElement('canvas');
    const ctx = textCanvas.getContext('2d');
    // enlarge canvas to get more detail (increase for more cubes)
    const W = 800;
    const H = 220;
    textCanvas.width = W;
    textCanvas.height = H;
    // background black
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,W,H);
    // text styling (pixelated look)
    const fontSize = 160;
    ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    // to pixelate, draw text multiple times or use low-res sampling later
    ctx.fillText(text, W/2, H/2 + 10);

    // sample image data
    const img = ctx.getImageData(0,0,W,H).data;

    // threshold & build points
    const pixels = [];
    // sample step controls resolution -> bigger step => fewer cubes
    const sampleStep = 8; // increase to reduce cubes for performance
    for(let y=0; y<H; y+=sampleStep){
      for(let x=0; x<W; x+=sampleStep){
        const idx = (x + y * W) * 4;
        const alpha = img[idx+3];
        const r = img[idx];
        // if pixel is light enough consider it part of text
        if(r > 50){
          // center origin
          const px = (x - W/2) * (pixelSize/ (sampleStep/4)) * scale / 2.8;
          const py = (H/2 - y) * (pixelSize/ (sampleStep/4)) * scale / 3.2;
          const pz = 0;
          pixels.push({x:px, y:py, z:pz});
        }
      }
    }

    // create instanced mesh
    const boxGeo = new THREE.BoxGeometry(pixelSize, pixelSize, pixelSize);
    const boxMat = new THREE.MeshStandardMaterial({
      color:0x8B0000,
      metalness:0.2,
      roughness:0.6,
      emissive: 0x440000,
      emissiveIntensity: 0.6
    });

    const count = pixels.length;
    const instanced = new THREE.InstancedMesh(boxGeo, boxMat, count);
    instanced.castShadow = true;
    instanced.receiveShadow = true;
    scene.add(instanced);

    // per-instance data
    const dummy = new THREE.Object3D();
    const basePositions = new Array(count);
    const velocity = new Array(count).fill().map(()=>({x:0,y:0,z:0}));
    const touched = new Array(count).fill(0);

    for(let i=0;i<count;i++){
      const p = pixels[i];
      basePositions[i] = new THREE.Vector3(p.x, p.y+2.0, p.z);
      dummy.position.set(p.x, p.y+2.0, p.z);
      dummy.rotation.set(0, (Math.random()-0.5)*0.4, 0);
      dummy.updateMatrix();
      instanced.setMatrixAt(i, dummy.matrix);
      // set color via instanceColor if needed (but default material used)
    }
    instanced.instanceMatrix.needsUpdate = true;

    // Add subtle floating (idle) effect onto base positions
    const clock = new THREE.Clock();

    // Raycaster for pointer interaction
    const ray = new THREE.Raycaster();
    const pointer = new THREE.Vector2(-1,-1);
    let mouseDown = false;

    // Map pointer on move to world position around pixel cloud center
    function getPointerWorld(event){
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      pointer.x = x; pointer.y = y;
      ray.setFromCamera(pointer, camera);
      // intersect with imaginary plane at z=0 near text
      const planeZ = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
      const intersect = new THREE.Vector3();
      ray.ray.intersectPlane(planeZ, intersect);
      return intersect;
    }

    // Interaction: attract nearby pixels towards pointer
    function interactAt(worldPos, strength=1.0){
      const radius = 20 + 20*strength; // influence radius
      for(let i=0;i<count;i++){
        const bp = basePositions[i];
        const dx = bp.x - worldPos.x;
        const dy = bp.y - worldPos.y;
        const dz = bp.z - worldPos.z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        if(dist < radius){
          // normalized direction from pixel -> pointer
          const dirx = (worldPos.x - bp.x) / (dist + 0.0001);
          const diry = (worldPos.y - bp.y) / (dist + 0.0001);
          const dirz = (worldPos.z - bp.z) / (dist + 0.0001);
          // add velocity towards pointer (so cubes "pulled")
          const pull = (1 - dist/radius) * (4.0 * strength);
          velocity[i].x += dirx * pull;
          velocity[i].y += diry * pull;
          velocity[i].z += dirz * pull;
          touched[i] = 1.0;
        }
      }
    }

    // Pointer events
    renderer.domElement.addEventListener('pointermove', (e)=>{
      const wpos = getPointerWorld(e);
      // continuous light attraction
      interactAt(wpos, 0.5);
    });

    renderer.domElement.addEventListener('pointerdown', (e)=>{
      mouseDown = true;
      const wpos = getPointerWorld(e);
      interactAt(wpos, 1.6);
      // burst of embers near pointer
      for(let i=0;i<emberCount;i++){
        positions[i*3+0] = positions[i*3+0] + (Math.random()-0.5)*10;
        positions[i*3+1] = positions[i*3+1] + (Math.random()*6)+6;
        positions[i*3+2] = positions[i*3+2] + (Math.random()-0.5)*10;
      }
      emberGeo.attributes.position.needsUpdate = true;
    });

    renderer.domElement.addEventListener('pointerup', ()=>{ mouseDown = false; });

    // Pause button behaviour
    const btn = document.getElementById('btn-pause');
    let paused = false;
    btn.addEventListener('click', ()=>{
      paused = !paused;
      btn.textContent = paused ? 'Resume' : 'Pause';
      controls.enabled = !paused;
    });

    // For keyboard toggles
    window.addEventListener('keydown', (ev)=>{
      if(ev.key === 'p' || ev.key === 'P'){
        paused = !paused;
        btn.textContent = paused ? 'Resume' : 'Pause';
        controls.enabled = !paused;
      }
    });

    // main animation loop
    function animate(){
      if(!paused){
        const t = clock.getElapsedTime();
        // animate lava vertices (simple procedural)
        const posAttr = lava.geometry.attributes.position;
        for(let i=0;i<posAttr.count;i++){
          const vx = posAttr.getX(i);
          const vy = posAttr.getY(i);
          const vz = posAttr.getZ(i);
          const n = simplex.noise3D(vx*0.02, vz*0.02, t*0.25);
          posAttr.setY(i, -30 + n*2.6 + Math.sin(t*0.6 + vx*0.03)*0.3);
        }
        posAttr.needsUpdate = true;
        lava.geometry.computeVertexNormals();

        // embers slight rise & wrap
        for(let i=0;i<emberCount;i++){
          positions[i*3+1] += 0.02 + Math.random()*0.2;
          if(positions[i*3+1] > 60) positions[i*3+1] = -10 - Math.random()*20;
        }
        emberGeo.attributes.position.needsUpdate = true;

        // update instanced cubes
        for(let i=0;i<count;i++){
          // idle breathing using noise
          const bp = basePositions[i];
          const n = simplex.noise3D(bp.x*0.02, bp.y*0.02, t*0.5);
          // apply velocity damping
          velocity[i].x *= 0.92;
          velocity[i].y *= 0.88;
          velocity[i].z *= 0.92;

          // update virtual position (base + small offset)
          const ox = bp.x + Math.sin(t*1.2 + i) * 0.05 + velocity[i].x;
          const oy = bp.y + Math.cos(t*1.1 + i*0.5) * 0.04 + velocity[i].y;
          const oz = bp.z + n*0.6 + velocity[i].z;

          dummy.position.set(ox, oy, oz);
          // rotation depends on how much it's moved (for wobble)
          const rot = Math.min(0.6, Math.abs(velocity[i].x)+Math.abs(velocity[i].y))*0.12;
          dummy.rotation.set(rot * Math.sin(i), (i%2?rot:-rot), rot * Math.cos(i*0.3));
          // slight scale bounce based on touched
          const shake = 1 + Math.min(0.45, touched[i]*0.5);
          dummy.scale.set(shake, shake, shake);
          dummy.updateMatrix();
          instanced.setMatrixAt(i, dummy.matrix);

          // decay touched marker
          touched[i] = Math.max(0, touched[i] - 0.02);
        }
        instanced.instanceMatrix.needsUpdate = true;
      }

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // Responsiveness
    window.addEventListener('resize', ()=>{
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    });

    // initial camera fly-in using GSAP
    gsap.fromTo(camera.position, { z: 220, y:40 }, { z: 120, y:30, duration: 2.2, ease:'power2.out' });

    // touch drag support (map touch to pointermove)
    let lastTouch = null;
    renderer.domElement.addEventListener('touchstart', (ev)=>{
      ev.preventDefault();
      const t = ev.touches[0];
      lastTouch = t;
      const wpos = getPointerWorld(t);
      interactAt(wpos, 1.0);
    }, {passive:false});
    renderer.domElement.addEventListener('touchmove', (ev)=>{
      ev.preventDefault();
      const t = ev.touches[0];
      const wpos = getPointerWorld(t);
      interactAt(wpos, 0.6);
    }, {passive:false});
    renderer.domElement.addEventListener('touchend', ()=>{ lastTouch = null; });

    // subtle camera oscillation (float)
    gsap.to(camera.rotation, { x: 0.02, y: -0.02, z: 0.0, duration: 8, ease:'sine.inOut', yoyo:true, repeat:-1 });

    // simple cleanup when page hidden
    document.addEventListener('visibilitychange', () => {
      if(document.hidden) renderer.setAnimationLoop(null);
    });

    // expose some debug to window (optional)
    window._ziaan_debug = { scene, camera, renderer, instanced };
  })();
  </script>
</body>
</html>
